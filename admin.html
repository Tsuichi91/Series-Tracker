<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Watch Tracker ‚Ä¢ Admin</title>
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- XLSX support -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    /* Simple tabs */
    .tabs { display:flex; gap:8px; margin:12px 0; }
    .tab-btn { cursor:pointer; }
    .tab-btn.active{ border-color:var(--accent); box-shadow:0 0 0 2px rgba(45,212,191,.18) inset; }
    .tab-pane{ display:none; }
    .tab-pane.active{ display:block; }
    /* Edit form */
    .edit-grid{ display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:12px; }
    @media (max-width:900px){ .edit-grid{ grid-template-columns:1fr; } }
    .readonly{ opacity:.8 }
  </style>
</head>
<body>
  <header>
    <div class="bar">
      <div class="logo"><span class="logo-icon"></span><span>Admin</span></div>
      <div class="spacer"></div>
      <a class="link-btn" href="index.html">üè† Overview</a>
      <a class="link-btn" href="dashboard.html">üìä Dashboard</a>
    </div>
  </header>

  <main class="container">
    <!-- Auth -->
    <section class="card" style="padding:14px">
      <h2>Authentication</h2>
      <div class="toolbar">
        <button class="icon-btn" id="btnSignIn">Sign in</button>
        <button class="icon-btn" id="btnSignOut">Sign out</button>
        <div class="avatar" id="avatar"></div>
        <div id="authInfo" class="muted">Not signed in.</div>
      </div>
    </section>

    <!-- Gate -->
    <section class="card" id="accessCard" style="padding:14px">
      <h2>Access</h2>
      <div id="gateMsg" class="muted">Please sign in to see the admin tools.</div>
    </section>

    <!-- Admin tools -->
    <div id="adminContent" style="display:none">
      <!-- Tabs -->
      <div class="tabs">
        <button class="icon-btn tab-btn active" data-tab="upload">‚¨ÜÔ∏è Upload to database</button>
        <button class="icon-btn tab-btn" data-tab="edit">‚úèÔ∏è Edit records</button>
      </div>

      <!-- ============ TAB: UPLOAD ============ -->
      <div id="tab-upload" class="tab-pane active">
        <!-- Quick Add -->
        <section class="card" style="padding:14px">
          <h2>Quick Add</h2>
          <div class="grid">
            <div class="field"><label>Type</label>
              <select id="qaType"><option value="movie">movie</option><option value="series">series</option></select>
            </div>
            <div class="field"><label>Title (EN)</label><input id="qaTitle" placeholder="Inception"/></div>
            <div class="field"><label>Original title</label><input id="qaOriginal" placeholder="Ïò§Î¶¨ÏßÄÎÑê Ï†úÎ™© (optional)"/></div>
            <div class="field"><label>Year</label><input id="qaYear" type="number" placeholder="2010"/></div>
            <div class="field"><label>Poster URL</label><input id="qaPoster" placeholder="https://..."/></div>
            <div class="field"><label>Backdrop URL</label><input id="qaBackdrop" placeholder="https://..."/></div>
            <div class="field"><label>Genres (pipe | separated)</label><input id="qaGenres" placeholder="Action|Sci-Fi"/></div>
            <div class="field"><label>Age Rating</label><input id="qaAge" placeholder="PG-13 / FSK 16"/></div>
            <div class="field"><label>Runtime (min) ‚Äì movie</label><input id="qaRuntime" type="number" placeholder="148"/></div>
            <div class="field"><label>Platform ‚Äì series</label><input id="qaPlatform" placeholder="Netflix"/></div>
          </div>
          <div class="toolbar">
            <button class="icon-btn" id="btnQuickAdd">Save</button>
          </div>
        </section>

        <!-- Import -->
        <section class="card" style="padding:14px">
          <h2>Import (CSV/XLSX) ‚Ä¢ Mapping & Workbook</h2>
          <div class="toolbar">
            <label class="icon-btn" for="csvFile">Choose CSV/XLSX</label>
            <input id="csvFile" type="file" accept=".csv,.xlsx,.xls" style="display:none" />
            <span class="pill">Dataset
              <select id="mapDataset">
                <option value="movies">movies</option>
                <option value="series">series</option>
                <option value="episodes">episodes</option>
              </select>
            </span>
            <span class="pill">Duplicates
              <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="chkDupSlug" checked> slug</label>
              <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="chkDupTitleYear" checked> title+year</label>
            </span>
          </div>
          <div id="mapTable"></div>
          <div id="mapPreview" class="muted"></div>
          <div class="toolbar">
            <button class="icon-btn" id="mapImport">Import now</button>
          </div>
        </section>
      </div>

      <!-- ============ TAB: EDIT ============ -->
      <div id="tab-edit" class="tab-pane">
        <section class="card" style="padding:14px">
          <h2>Edit records</h2>
          <div class="toolbar">
            <span class="pill">
              <label>Dataset</label>
              <select id="editDataset">
                <option value="movies">movies</option>
                <option value="series">series</option>
              </select>
            </span>
            <span class="pill" style="flex:1; min-width:260px">
              <label>Choose item</label>
              <select id="editSelect" style="width:100%"><option value="">‚Äî</option></select>
            </span>
            <span class="pill" style="flex:1; min-width:220px">
              <label>Search</label>
              <input id="editSearch" placeholder="type to filter by title‚Ä¶"/>
            </span>
            <button class="icon-btn" id="editReload">Reload</button>
          </div>

          <div id="editMeta" class="muted" style="margin:6px 2px 10px"></div>

          <div id="editForm" class="edit-grid"></div>

          <div class="toolbar">
            <button class="icon-btn" id="editSave">üíæ Save changes</button>
            <button class="icon-btn" id="editDelete">üóë Soft delete</button>
          </div>
        </section>
      </div>
    </div>
  </main>

  <div class="toast" id="toast"></div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
    import { getFirestore, collection, doc, setDoc, getDocs, getDoc, query, orderBy } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

    // ---------- Config ----------
    async function loadConfig(){
      for (const p of ["firebase.config.json","firebase.config.example.json"]) { try { const r = await fetch(p); if(r.ok) return r.json(); } catch(e) {} }
      throw new Error("Missing firebase.config.json");
    }
    const cfg = await loadConfig();
    const app = initializeApp(cfg);

    // ---------- Auth ----------
    const auth = getAuth(app);
    const provider = new GoogleAuthProvider();
    const avatar = document.getElementById('avatar');
    const info   = document.getElementById('authInfo');
    const db = getFirestore(app);

    function showToast(msg){ const t=document.getElementById('toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none',1800); }

    document.getElementById('btnSignIn').addEventListener('click', async()=>{ await signInWithPopup(auth, provider); });
    document.getElementById('btnSignOut').addEventListener('click', async()=>{ await signOut(auth); });

    let isAuthorized = false;

    async function checkAccess(user){
      try{
        const ref = doc(db, 'adminUsers', user.uid);
        const snap = await getDoc(ref);
        if(snap.exists()){
          const d = snap.data();
          return (d.active !== false) && (d.role === 'admin' || d.admin === true || (Array.isArray(d.roles) && d.roles.includes('admin')));
        }
      }catch(err){ console.warn('Access check failed', err); }
      return false;
    }

    function setGate({ signedIn, authorized }){
      const accessCard = document.getElementById('accessCard');
      const adminContent = document.getElementById('adminContent');
      const gateMsg = document.getElementById('gateMsg');
      if(!signedIn){
        gateMsg.textContent = 'Please sign in to see the admin tools.';
        accessCard.style.display = 'block';
        adminContent.style.display = 'none';
      } else if(!authorized){
        gateMsg.textContent = 'You are signed in, but not authorized for Admin. Please contact an admin.';
        accessCard.style.display = 'block';
        adminContent.style.display = 'none';
      } else {
        accessCard.style.display = 'none';
        adminContent.style.display = 'block';
      }
    }

    onAuthStateChanged(auth, async (user)=>{
      if(user){
        avatar.style.display='flex';
        avatar.textContent = (user.displayName||user.email||'?').slice(0,1).toUpperCase();
        info.textContent = `Signed in as ${user.email||user.displayName}`;
        document.body.dataset.authed = '1';
        isAuthorized = await checkAccess(user);
        setGate({ signedIn:true, authorized:isAuthorized });
        if(isAuthorized){ await editReloadList(); }
      } else {
        avatar.style.display='none'; avatar.textContent='';
        info.textContent = 'Not signed in.';
        document.body.dataset.authed = '';
        isAuthorized = false;
        setGate({ signedIn:false, authorized:false });
      }
    });

    // ---------- Data model fields ----------
    const MOVIE_FIELDS = ["id","type","slug","title_en","title_original","year","poster","backdrop","short_description","genres","age_rating","runtime_min","release_date","franchise","status","rating","favorite","on_watchlist","tags","rewatch_count","rewatch_dates","last_position_seconds","created_at","updated_at"];
    const SERIES_FIELDS = ["id","type","slug","title_en","title_original","year","poster","backdrop","short_description","genres","age_rating","series_status","platform","episode_length_min","status","rating","favorite","on_watchlist","tags","rewatch_count","rewatch_dates","created_at","updated_at"];
    const EPISODE_FIELDS = ["series_slug","season_number","episode_number","code","title","air_date","watched","rating","notes","runtime_min"];

    function slugify(title, year){ return (title+"-"+year).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/-+/g,'-').replace(/^-|-$/g,''); }

    // ---------- Tabs ----------
    document.querySelectorAll('.tab-btn').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        document.querySelectorAll('.tab-btn').forEach(b=> b.classList.remove('active'));
        document.querySelectorAll('.tab-pane').forEach(p=> p.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('tab-'+btn.dataset.tab).classList.add('active');
      });
    });

    // ---------- Quick Add ----------
    document.getElementById('btnQuickAdd').addEventListener('click', async()=>{
      if(!(auth.currentUser)){ showToast('Please sign in first'); return; }
      if(!isAuthorized){ showToast('Not authorized'); return; }
      const type = (document.getElementById('qaType').value);
      const title_en = document.getElementById('qaTitle').value.trim();
      const title_original = document.getElementById('qaOriginal').value.trim();
      const year = Number(document.getElementById('qaYear').value);
      const poster = document.getElementById('qaPoster').value.trim();
      const backdrop = document.getElementById('qaBackdrop').value.trim();
      const genres = document.getElementById('qaGenres').value.trim();
      const age = document.getElementById('qaAge').value.trim();
      const runtime = Number(document.getElementById('qaRuntime').value);
      const platform = document.getElementById('qaPlatform').value.trim();
      if(!title_en || !year || !poster){ showToast('Need Title, Year, Poster'); return; }
      if(type==='movie' && !genres && !runtime){ showToast('Movie: need Genres or Runtime'); return; }
      if(type==='series' && !genres && !platform){ showToast('Series: need Genres or Platform'); return; }

      const slug = slugify(title_en, year);
      const base = { slug, title_en, title_original, year, poster, backdrop, short_description:'', genres: genres? genres.split('|') : [], age_rating: age, status:'Plan to Watch', rating:0, favorite:false, on_watchlist:false, tags:[], rewatch:{count:0,dates:[]}, created_at:new Date().toISOString(), updated_at:new Date().toISOString() };
      if(type==='movie'){
        await setDoc(doc(db,'movies', slug), { id: slug, type:'movie', ...base, runtime_min: runtime||0, release_date:'', franchise:null, last_position_seconds:0 }, { merge:true });
      } else {
        await setDoc(doc(db,'series', slug), { id: slug, type:'series', ...base, series_status:'running', platform, episode_length_min:0, seasons:[] }, { merge:true });
      }
      showToast('Saved');
      await editReloadList();
    });

    // ---------- Import context ----------
    const importCtx = { headers:[], rows:[], mapping:{}, dataset:'movies', workbook:null };

    // ---------- Mapping UI ----------
    function buildMapUI(){
      const dataset = importCtx.dataset;
      if (dataset === 'workbook'){
        const s = importCtx.workbook?.series?.length || 0;
        const se = importCtx.workbook?.seasons?.length || 0;
        const ep = importCtx.workbook?.episodes?.length || 0;
        document.getElementById('mapTable').innerHTML =
          `<div class="pill">Workbook detected: <strong>series ${s}</strong> ‚Ä¢ <strong>seasons ${se}</strong> ‚Ä¢ <strong>episodes ${ep}</strong></div>`;
        document.getElementById('mapPreview').innerHTML = '';
        return;
      }
      const fields =
        dataset==='movies'  ? MOVIE_FIELDS  :
        dataset==='series'  ? SERIES_FIELDS :
        EPISODE_FIELDS;

      importCtx.mapping = Object.fromEntries(fields.map(f=> [f, importCtx.headers.includes(f)? f : ""]));
      const sel = (name,val)=> `<select data-map="${name}"><option value="">(none)</option>${importCtx.headers.map(h=>`<option ${h===val?'selected':''}>${h}</option>`).join('')}</select>`;
      const rows = fields.map(f=> `<tr><td>${f}</td><td>${sel(f, importCtx.mapping[f])}</td></tr>`).join('');
      document.getElementById('mapTable').innerHTML = `<table class='table'><thead><tr><th>Field</th><th>File column</th></tr></thead><tbody>${rows}</tbody></table>`;
      document.querySelectorAll('#mapTable select').forEach(s=> s.addEventListener('change', e=>{ importCtx.mapping[e.target.dataset.map]=e.target.value; buildPreview(); }));
      buildPreview();
    }

    function buildPreview(){
      if (importCtx.dataset === 'workbook'){ return; }
      const fields =
        importCtx.dataset==='movies'  ? MOVIE_FIELDS  :
        importCtx.dataset==='series'  ? SERIES_FIELDS :
        EPISODE_FIELDS;

      const preview = importCtx.rows.slice(0,3).map((r,i)=>{
        const mapped = Object.fromEntries(fields.map(f=> [f, importCtx.mapping[f]? r[importCtx.mapping[f]] : '' ]));
        return `<pre>#${i+1} ${JSON.stringify(mapped, null, 2)}</pre>`;
      }).join('');
      document.getElementById('mapPreview').innerHTML = `<div>Preview (first 3 rows):</div>${preview}`;
    }

    // ---------- File reading ----------
    function readWorkbookAllSheets(file){
      return new Promise((resolve,reject)=>{
        const reader = new FileReader();
        reader.onload = (ev)=>{
          try{
            const data = new Uint8Array(ev.target.result);
            const wb = XLSX.read(data, { type:'array' });
            const get = (name)=> XLSX.utils.sheet_to_json(wb.Sheets[name] || {}, { defval:'' });
            resolve({ series:get('series'), seasons:get('seasons'), episodes:get('episodes') });
          }catch(err){ reject(err); }
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }

    function readSingleSheet(file){
      return new Promise((resolve,reject)=>{
        const reader = new FileReader();
        reader.onload = (ev)=>{
          try{
            const data = new Uint8Array(ev.target.result);
            const wb = XLSX.read(data, { type:'array' });
            const ws = wb.Sheets[wb.SheetNames[0]];
            const rows = XLSX.utils.sheet_to_json(ws, { defval:'' });
            resolve(rows);
          }catch(err){ reject(err); }
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }

    document.getElementById('csvFile').addEventListener('change', async (e)=>{
      const f = e.target.files[0]; if(!f) return;
      try{
        const name = (f.name||'').toLowerCase();
        if (name.endsWith('.xlsx') || name.endsWith('.xls')){
          const wb = await readWorkbookAllSheets(f);
          const hasAny = (wb.series?.length||0) + (wb.seasons?.length||0) + (wb.episodes?.length||0) > 0;
          if (hasAny){
            importCtx.dataset = 'workbook';
            importCtx.workbook = wb;
            importCtx.headers = []; importCtx.rows = [];
            buildMapUI();
          } else {
            const rows = await readSingleSheet(f);
            importCtx.headers = rows.length? Object.keys(rows[0]) : [];
            importCtx.rows = rows;
            importCtx.dataset = document.getElementById('mapDataset').value;
            buildMapUI();
          }
        } else {
          await new Promise((resolve)=>{
            Papa.parse(f, { header:true, skipEmptyLines:true, complete: (res)=>{
              importCtx.headers = res.meta.fields||[];
              importCtx.rows = res.data||[];
              resolve();
            }});
          });
          importCtx.dataset = document.getElementById('mapDataset').value;
          buildMapUI();
        }
      }catch(err){
        console.error(err);
        showToast('Failed to read file');
      }finally{
        e.target.value='';
      }
    });

    document.getElementById('mapDataset').addEventListener('change', ()=>{
      if(importCtx.dataset !== 'workbook'){ importCtx.dataset = document.getElementById('mapDataset').value; buildMapUI(); }
    });

    // ---------- Import logic ----------
    async function runImport(){
      if(!(auth.currentUser)){ showToast('Please sign in first'); return; }
      if(!isAuthorized){ showToast('Not authorized'); return; }

      // Workbook flow
      if (importCtx.dataset === 'workbook'){
        let sAdded=0,sUpdated=0,seaAdded=0,epAdded=0,epUpdated=0,missing=0;

        // SERIES
        for (const obj of (importCtx.workbook.series||[])){
          if(!obj.slug || !obj.title_en) continue;
          obj.type = 'series';
          obj.genres = String(obj.genres||'').split('|').filter(Boolean);
          obj.tags   = String(obj.tags||'').split('|').filter(Boolean);
          obj.favorite = String(obj.favorite).toLowerCase()==='true';
          obj.on_watchlist = String(obj.on_watchlist).toLowerCase()==='true';
          obj.rating = Number(obj.rating||0)||0;
          obj.year = Number(obj.year||0)||0;
          const ref = doc(db,'series', obj.slug);
          const ex  = await getDoc(ref);
          await setDoc(ref, { ...obj, updated_at:new Date().toISOString() }, { merge:true });
          ex.exists() ? sUpdated++ : sAdded++;
        }

        // SEASONS
        for (const r of (importCtx.workbook.seasons||[])){
          const slug = String(r.series_slug||'').trim(); if(!slug) continue;
          const sNum = Number(r.season_number||0); if(!sNum) continue;
          const sRef = doc(db,'series', slug); const sSnap = await getDoc(sRef);
          if(!sSnap.exists()){ missing++; continue; }
          const serie   = sSnap.data()||{};
          const seasons = Array.isArray(serie.seasons)? [...serie.seasons] : [];
          let idx = seasons.findIndex(s=> Number(s.season_number)===sNum);
          if(idx === -1){ seasons.push({ season_number:sNum, episodes:[], title:r.season_title||'', note:r.note||'' }); seaAdded++; }
          else { seasons[idx] = { ...seasons[idx], title:r.season_title||seasons[idx].title, note:r.note||seasons[idx].note }; }
          await setDoc(sRef, { seasons, updated_at:new Date().toISOString() }, { merge:true });
        }

        // EPISODES
        const pad2 = n => String(Math.max(0, Number(n)||0)).padStart(2,'0');
        const bySeries = {};
        for (const r of (importCtx.workbook.episodes||[])){
          const slug = String(r.series_slug||'').trim(); if(!slug) continue;
          (bySeries[slug] ||= []).push(r);
        }
        for (const slug of Object.keys(bySeries)){
          const sRef = doc(db,'series', slug); const snap = await getDoc(sRef);
          if(!snap.exists()){ missing++; continue; }
          const serie = snap.data()||{};
          const seasons = Array.isArray(serie.seasons)? [...serie.seasons] : [];

          const ensureSeason = (num)=>{
            let i = seasons.findIndex(s=> Number(s.season_number)===Number(num));
            if(i===-1){ seasons.push({ season_number:Number(num), episodes:[] }); i=seasons.length-1; }
            if(!Array.isArray(seasons[i].episodes)) seasons[i].episodes=[];
            return i;
          };

          for (const r of bySeries[slug]){
            const sNum = Number(r.season_number||1);
            const eNum = Number(r.episode_number||0);
            const idx  = ensureSeason(sNum);
            const code = String(r.code||`S${pad2(sNum)}E${pad2(eNum)}`);
            const ep = {
              code,
              episode_number: eNum || undefined,
              title: r.title || '',
              air_date: r.air_date || '',
              watched: String(r.watched).toLowerCase()==='true',
              rating: Number(r.rating||0)||0,
              notes: r.notes || '',
              runtime_min: Number(r.runtime_min||0) || undefined
            };
            const list = seasons[idx].episodes;
            const byCode = list.findIndex(x => (x.code||'') === code);
            const byNum  = list.findIndex(x => Number(x.episode_number||0) === eNum && eNum>0);
            if (byCode>=0 || byNum>=0){ list[byCode>=0?byCode:byNum] = { ...list[byCode>=0?byCode:byNum], ...ep }; epUpdated++; }
            else { list.push(ep); epAdded++; }
            list.sort((a,b)=>{
              const an=Number(a.episode_number||0), bn=Number(b.episode_number||0);
              return an && bn ? an-bn : String(a.code||'').localeCompare(String(b.code||''));
            });
          }
          await setDoc(sRef, { seasons, updated_at:new Date().toISOString() }, { merge:true });
        }

        showToast(`Workbook: series +${sAdded}/${sUpdated} ‚Ä¢ seasons +${seaAdded} ‚Ä¢ episodes +${epAdded}/${epUpdated}${missing?` ‚Ä¢ missing series ${missing}`:''}`);
        await editReloadList();
        return;
      }

      // Mapping flow (single sheet CSV/XLSX)
      const fields = (importCtx.dataset==='movies'? MOVIE_FIELDS : importCtx.dataset==='series' ? SERIES_FIELDS : EPISODE_FIELDS);
      const dupSlug = document.getElementById('chkDupSlug').checked;
      const dupTY = document.getElementById('chkDupTitleYear').checked;
      let added=0, skipped=0, duplicates=0, updated=0;

      if (importCtx.dataset === 'episodes'){
        const bySeries = {};
        for (const r of importCtx.rows){
          const row = Object.fromEntries(fields.map(f=> [f, importCtx.mapping[f] ? r[importCtx.mapping[f]] : '' ]));
          const slug = String(row.series_slug||'').trim(); if(!slug) { skipped++; continue; }
          (bySeries[slug] ||= []).push(row);
        }
        const pad2 = n => String(Math.max(0, Number(n)||0)).padStart(2,'0');

        for (const slug of Object.keys(bySeries)){
          const sRef = doc(db, 'series', slug);
          const sSnap = await getDoc(sRef);
          if(!sSnap.exists()){ skipped++; continue; }
          const serie = sSnap.data() || {};
          const seasons = Array.isArray(serie.seasons) ? [...serie.seasons] : [];

          const ensureSeason = (num)=>{
            let i = seasons.findIndex(s=> Number(s.season_number)===Number(num));
            if (i === -1){ seasons.push({ season_number:Number(num), episodes:[] }); i = seasons.length - 1; }
            if(!Array.isArray(seasons[i].episodes)) seasons[i].episodes = [];
            return i;
          };

          for (const r of bySeries[slug]){
            const sNum = Number(r.season_number||1);
            const eNum = Number(r.episode_number||0);
            const idx  = ensureSeason(sNum);
            const code = String(r.code||`S${pad2(sNum)}E${pad2(eNum)}`);
            const ep = {
              code,
              episode_number: eNum || undefined,
              title: r.title || '',
              air_date: r.air_date || '',
              watched: String(r.watched).toLowerCase()==='true',
              rating: Number(r.rating||0)||0,
              notes: r.notes || '',
              runtime_min: Number(r.runtime_min||0) || undefined
            };
            const list = seasons[idx].episodes;
            const byCode = list.findIndex(x => (x.code||'') === code);
            const byNum  = list.findIndex(x => Number(x.episode_number||0) === eNum && eNum>0);
            if (byCode>=0 || byNum>=0){ list[byCode>=0?byCode:byNum] = { ...list[byCode>=0?byCode:byNum], ...ep }; updated++; }
            else { list.push(ep); added++; }
            list.sort((a,b)=>{
              const an=Number(a.episode_number||0), bn=Number(b.episode_number||0);
              return an && bn ? an-bn : String(a.code||'').localeCompare(String(b.code||''));
            });
          }

          await setDoc(sRef, { seasons, updated_at:new Date().toISOString() }, { merge:true });
        }
        showToast(`Episodes: +${added} updated ${updated}${skipped?` ‚Ä¢ skipped ${skipped}`:''}`);
        await editReloadList();
        return;
      }

      // movies / series
      for (const r of importCtx.rows){
        const obj = Object.fromEntries(fields.map(f=> [f, importCtx.mapping[f]? r[importCtx.mapping[f]] : '' ]));
        const type = importCtx.dataset.slice(0,-1); // movie / series
        obj.type = type;
        obj.year = Number(String(obj.year).replace(',','.'))||0;
        obj.genres = (obj.genres||'').split('|').filter(Boolean);
        obj.tags = (obj.tags||'').split('|').filter(Boolean);
        obj.rating = Number(String(obj.rating).replace(',','.'))||0;
        obj.favorite = String(obj.favorite).toLowerCase()==='true';
        obj.on_watchlist = String(obj.on_watchlist).toLowerCase()==='true';
        obj.rewatch = { count: Number(obj.rewatch_count||0)||0, dates: (obj.rewatch_dates||'').split('|').filter(Boolean) };
        obj.created_at = obj.created_at || new Date().toISOString();
        obj.updated_at = obj.updated_at || new Date().toISOString();
        if(!obj.slug && obj.title_en && obj.year){ obj.slug = slugify(obj.title_en, obj.year); }

        if(!(obj.title_en && obj.year && obj.poster)){ skipped++; continue; }
        if(type==='movie' && !(obj.genres.length>0 || Number(obj.runtime_min||0)>0)){ skipped++; continue; }
        if(type==='series' && !(obj.genres.length>0 || (obj.platform||''))){ skipped++; continue; }

        const ref = doc(db, importCtx.dataset, obj.slug);
        if(dupSlug){ const ex = await getDoc(ref); if(ex.exists()){ duplicates++; skipped++; continue; } }
        if(dupTY){
          const all = await getDocs(collection(db, importCtx.dataset));
          const collision = all.docs.some(d=> (d.data().title_en||'')===obj.title_en && String(d.data().year||'')===String(obj.year||''));
          if(collision){ duplicates++; skipped++; continue; }
        }
        await setDoc(ref, obj, { merge:true });
        added++;
      }
      showToast(`Imported ${added}, skipped ${skipped}${duplicates? ' (duplicates '+duplicates+')':''}`);
      await editReloadList();
    }
    document.getElementById('mapImport').addEventListener('click', runImport);

    // ---------- EDIT TAB ----------
    const editState = { dataset:'movies', list:[], currentId:'', currentDoc:null };

    // NEW: normalize dataset names (defensiv)
    const normalizeDataset = (v) => (v === 'movie' ? 'movies' : v === 'series' ? 'series' : v);

    document.getElementById('editDataset').addEventListener('change', async (e)=>{ 
      editState.dataset = normalizeDataset(e.target.value); 
      await editReloadList(); 
    });
    document.getElementById('editReload').addEventListener('click', editReloadList);
    document.getElementById('editSearch').addEventListener('input', ()=> fillEditSelect());

    async function editReloadList(){
      if(!isAuthorized) return;
      const coll = normalizeDataset(editState.dataset);
      const out=[];
      try{
        const snap = await getDocs(query(collection(db, coll), orderBy('title_en','asc')));
        snap.forEach(d=> out.push({ id:d.id, ...d.data() }));
      }catch{
        const snap = await getDocs(collection(db, coll));
        snap.forEach(d=> out.push({ id:d.id, ...d.data() }));
      }
      // Filter soft-deleted & sort
      const clean = out.filter(x=> x.__deleted !== true)
                       .sort((a,b)=> (a.title_en||'').localeCompare(b.title_en||''));
      editState.list = clean;
      fillEditSelect();
    }

    function fillEditSelect(){
      const sel = document.getElementById('editSelect');
      const q = (document.getElementById('editSearch').value||'').toLowerCase();
      const items = editState.list.filter(x=> !q || (x.title_en||'').toLowerCase().includes(q));
      sel.innerHTML = '<option value="">‚Äî</option>' + items.map(x=>{
        const label = `${x.title_en||'(no title)'} ${x.year? '('+x.year+')':''} ‚Äî ${x.slug||x.id}`;
        // value = echte Doc-ID, nicht slug
        return `<option value="${x.id}">${label}</option>`;
      }).join('');
      document.getElementById('editMeta').textContent = `${items.length} items`;
      document.getElementById('editForm').innerHTML = '';
      editState.currentId = ''; editState.currentDoc = null;
    }

    // NEW: robust lookup ‚Äì erst Doc-ID, dann slug-Fallback
    async function resolveDocByIdOrSlug(collName, key) {
      collName = normalizeDataset(collName);
      // a) per Doc-ID
      let snap = await getDoc(doc(db, collName, key));
      if (snap.exists()) return snap;
      // b) Fallback: suche per slug
      const all = await getDocs(collection(db, collName));
      const hit = all.docs.find(d => (d.data()?.slug || '') === key);
      return hit || null;
    }

    document.getElementById('editSelect').addEventListener('change', async (e)=>{
      const id = e.target.value;
      if(!id){ document.getElementById('editForm').innerHTML=''; return; }
      const coll = normalizeDataset(editState.dataset);

      const snap = await resolveDocByIdOrSlug(coll, id);
      if(!snap){ showToast(`Item not found in ${coll}: ${id}`); return; }

      editState.currentId = snap.id;
      editState.currentDoc = { id: snap.id, ...snap.data() };
      buildEditForm();
    });

    function fieldRow(id,label,html){ return `<div class="field"><label for="${id}">${label}</label>${html}</div>`; }
    function text(id,ph='',val=''){ return `<input id="${id}" value="${val??''}" placeholder="${ph}"/>`; }
    function num(id,ph='',val=''){ return `<input id="${id}" type="number" value="${val??''}" placeholder="${ph}"/>`; }
    function ta(id,ph='',val=''){ return `<textarea id="${id}" rows="3" placeholder="${ph}">${val??''}</textarea>`; }
    function cb(id,checked){ return `<label style="display:flex;align-items:center;gap:8px"><input id="${id}" type="checkbox" ${checked?'checked':''}/> <span>${id.includes('Fav')?'favorite':'enabled'}</span></label>`; }

    function buildEditForm(){
      const d = editState.currentDoc || {};
      const isMovie = (normalizeDataset(editState.dataset)==='movies');

      const common = [
        fieldRow('efSlug','Slug', `<input id="efSlug" value="${d.slug||d.id||''}" class="readonly" disabled/>`),
        fieldRow('efTitle','Title (EN)', text('efTitle','', d.title_en||'')),
        fieldRow('efOrig','Original title', text('efOrig','', d.title_original||'')),
        fieldRow('efYear','Year', num('efYear','', d.year||'')),
        fieldRow('efPoster','Poster URL', text('efPoster','https://‚Ä¶', d.poster||'')),
        fieldRow('efBackdrop','Backdrop URL', text('efBackdrop','https://‚Ä¶', d.backdrop||'')),
        fieldRow('efDesc','Short description', ta('efDesc','', d.short_description||'')),
        fieldRow('efGenres','Genres (| separated)', text('efGenres','Action|Sci-Fi', (d.genres||[]).join('|'))),
        fieldRow('efAge','Age rating', text('efAge','PG-13 / FSK 16', d.age_rating||'')),
        fieldRow('efStatus','Status', text('efStatus','Plan to Watch / In Progress / Completed', d.status||'')),
        fieldRow('efRating','Rating (0‚Äì5)', num('efRating','', d.rating||0)),
        fieldRow('efFav','Favorite', cb('efFav', !!d.favorite)),
        fieldRow('efWl','On watchlist', cb('efWl', !!d.on_watchlist)),
        fieldRow('efTags','Tags (| separated)', text('efTags','Sci-Fi|Classic', (d.tags||[]).join('|')))
      ];

      const movieOnly = [
        fieldRow('efRuntime','Runtime (min)', num('efRuntime','', d.runtime_min||'')),
        fieldRow('efRel','Release date (YYYY-MM-DD)', text('efRel','2024-12-31', d.release_date||'')),
        fieldRow('efFranchise','Franchise', text('efFranchise','Marvel / ‚Äî', d.franchise||'')),
        fieldRow('efPos','Last position (sec)', num('efPos','', d.last_position_seconds||0))
      ];
      const seriesOnly = [
        fieldRow('efPlatform','Platform', text('efPlatform','Netflix', d.platform||'')),
        fieldRow('efEpLen','Episode length (min)', num('efEpLen','', d.episode_length_min||'')),
        fieldRow('efSeriesStatus','Series status', text('efSeriesStatus','running / ended', d.series_status||''))
      ];

      const html = (isMovie ? [...common, ...movieOnly] : [...common, ...seriesOnly]).join('');
      document.getElementById('editForm').innerHTML = html;

      document.getElementById('editMeta').innerHTML =
        `Editing <strong>${d.title_en||'(no title)'}</strong> (${d.year||'‚Äî'}) ‚Ä¢ <span class="muted">id/slug: ${d.slug||d.id}</span>`;
    }

    document.getElementById('editSave').addEventListener('click', async ()=>{
      if(!(auth.currentUser) || !isAuthorized){ showToast('Not authorized'); return; }
      if(!editState.currentId){ showToast('Pick an item first'); return; }
      const isMovie = (normalizeDataset(editState.dataset)==='movies');
      const coll = normalizeDataset(editState.dataset);
      const id   = editState.currentId;
      const ref  = doc(db, coll, id);

      const val = (id)=> (document.getElementById(id)?.value ?? '').trim();
      const numVal = (id)=> Number(val(id)||0) || 0;
      const boolVal = (id)=> !!document.getElementById(id)?.checked;

      const base = {
        title_en: val('efTitle'),
        title_original: val('efOrig'),
        year: numVal('efYear'),
        poster: val('efPoster'),
        backdrop: val('efBackdrop'),
        short_description: document.getElementById('efDesc')?.value || '',
        genres: (val('efGenres')||'').split('|').filter(Boolean),
        age_rating: val('efAge'),
        status: val('efStatus'),
        rating: Number(val('efRating')||0) || 0,
        favorite: boolVal('efFav'),
        on_watchlist: boolVal('efWl'),
        tags: (val('efTags')||'').split('|').filter(Boolean),
        updated_at: new Date().toISOString()
      };

      let patch = {};
      if(isMovie){
        patch = {
          ...base,
          type:'movie',
          runtime_min: numVal('efRuntime'),
          release_date: val('efRel'),
          franchise: val('efFranchise') || null,
          last_position_seconds: numVal('efPos')
        };
      } else {
        patch = {
          ...base,
          type:'series',
          platform: val('efPlatform'),
          episode_length_min: numVal('efEpLen'),
          series_status: val('efSeriesStatus')
        };
      }

      await setDoc(ref, patch, { merge:true });
      showToast('Saved changes');
      await editReloadList();
      // keep selection
      document.getElementById('editSelect').value = id;
    });

    document.getElementById('editDelete').addEventListener('click', async ()=>{
      if(!(auth.currentUser) || !isAuthorized){ showToast('Not authorized'); return; }
      if(!editState.currentId){ showToast('Pick an item first'); return; }
      const coll = normalizeDataset(editState.dataset);
      const id   = editState.currentId;
      await setDoc(doc(db, coll, id), { __deleted:true, updated_at:new Date().toISOString() }, { merge:true });
      showToast('Marked as deleted (soft delete)');
      await editReloadList();
    });

    // ---------- Import wire ----------
    document.getElementById('mapImport').addEventListener('click', runImport);

  </script>
</body>
</html>
