<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Watch Tracker ‚Ä¢ Admin</title>
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- XLSX support -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
  <header>
    <div class="bar">
      <div class="logo"><span class="logo-icon"></span><span>Admin</span></div>
      <div class="spacer"></div>
      <a class="link-btn" href="index.html">üè† Overview</a>
      <a class="link-btn" href="dashboard.html">üìä Dashboard</a>
    </div>
  </header>

  <main class="container">
    <!-- Auth section is always visible -->
    <section class="card" style="padding:14px">
      <h2>Authentication</h2>
      <div class="toolbar">
        <button class="icon-btn" id="btnSignIn">Sign in</button>
        <button class="icon-btn" id="btnSignOut">Sign out</button>
        <div class="avatar" id="avatar"></div>
        <div id="authInfo" class="muted">Not signed in.</div>
      </div>
    </section>

    <!-- Gate (sign-in + verification via Firestore collection) -->
    <section class="card" id="accessCard" style="padding:14px">
      <h2>Access</h2>
      <div id="gateMsg" class="muted">Please sign in to see the admin tools.</div>
    </section>

    <!-- Admin tools (hidden until authorized) -->
    <div id="adminContent" style="display:none">
      <section class="card" style="padding:14px">
        <h2>Quick Add</h2>
        <div class="grid">
          <div class="field"><label>Type</label>
            <select id="qaType"><option value="movie">movie</option><option value="series">series</option></select>
          </div>
          <div class="field"><label>Title (EN)</label><input id="qaTitle" placeholder="Inception"/></div>
          <div class="field"><label>Original title</label><input id="qaOriginal" placeholder="Ïò§Î¶¨ÏßÄÎÑê Ï†úÎ™© (optional)"/></div>
          <div class="field"><label>Year</label><input id="qaYear" type="number" placeholder="2010"/></div>
          <div class="field"><label>Poster URL</label><input id="qaPoster" placeholder="https://..."/></div>
          <div class="field"><label>Backdrop URL</label><input id="qaBackdrop" placeholder="https://..."/></div>
          <div class="field"><label>Genres (pipe | separated)</label><input id="qaGenres" placeholder="Action|Sci-Fi"/></div>
          <div class="field"><label>Age Rating</label><input id="qaAge" placeholder="PG-13 / FSK 16"/></div>
          <div class="field"><label>Runtime (min) ‚Äì movie</label><input id="qaRuntime" type="number" placeholder="148"/></div>
          <div class="field"><label>Platform ‚Äì series</label><input id="qaPlatform" placeholder="Netflix"/></div>
        </div>
        <div class="toolbar">
          <button class="icon-btn" id="btnQuickAdd">Save</button>
        </div>
      </section>

      <section class="card" style="padding:14px">
        <h2>Import (CSV/XLSX) ‚Ä¢ Mapping & Workbook</h2>
        <div class="toolbar">
          <label class="icon-btn" for="csvFile">Choose CSV/XLSX</label>
          <input id="csvFile" type="file" accept=".csv,.xlsx,.xls" style="display:none" />
          <span class="pill">Dataset
            <!-- Achtung: 'episodes' nur f√ºr CSV/Einzelsheet; XLSX-Workbook wird automatisch erkannt -->
            <select id="mapDataset">
              <option value="movies">movies</option>
              <option value="series">series</option>
              <option value="episodes">episodes</option>
            </select>
          </span>
          <span class="pill">Duplicates
            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="chkDupSlug" checked> slug</label>
            <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="chkDupTitleYear" checked> title+year</label>
          </span>
        </div>
        <div id="mapTable"></div>
        <div id="mapPreview" class="muted"></div>
        <div class="toolbar">
          <button class="icon-btn" id="mapImport">Import now</button>
        </div>
      </section>

      <section class="card" style="padding:14px">
        <h2>Content</h2>
        <table class="table" id="contentTable">
          <thead><tr><th>Type</th><th>Title</th><th>Year</th><th>Status</th><th>Platform</th><th>Rating</th><th>Updated</th><th>Actions</th></tr></thead>
          <tbody></tbody>
        </table>
      </section>
    </div>
  </main>

  <div class="toast" id="toast"></div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
    import { getFirestore, collection, doc, setDoc, getDocs, getDoc, query, orderBy } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

    // ---------- Config ----------
    async function loadConfig(){
      for (const p of ["firebase.config.json","firebase.config.example.json"]) { try { const r = await fetch(p); if(r.ok) return r.json(); } catch(e) {} }
      throw new Error("Missing firebase.config.json");
    }
    const cfg = await loadConfig();
    const app = initializeApp(cfg);

    // ---------- Auth ----------
    const auth = getAuth(app);
    const provider = new GoogleAuthProvider();
    const avatar = document.getElementById('avatar');
    const info   = document.getElementById('authInfo');

    function showToast(msg){ const t=document.getElementById('toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none',1800); }

    document.getElementById('btnSignIn').addEventListener('click', async()=>{ await signInWithPopup(auth, provider); });
    document.getElementById('btnSignOut').addEventListener('click', async()=>{ await signOut(auth); });

    const db = getFirestore(app);
    let isAuthorized = false;

    async function checkAccess(user){
      try{
        // Verification via Firestore collection "adminUsers"
        // Example document (id = user.uid): { role: 'admin', active: true, email: 'name@example.com' }
        const ref = doc(db, 'adminUsers', user.uid);
        const snap = await getDoc(ref);
        if(snap.exists()){
          const d = snap.data();
          return (d.active !== false) && (d.role === 'admin' || d.admin === true || (Array.isArray(d.roles) && d.roles.includes('admin')));
        }
      }catch(err){ console.warn('Access check failed', err); }
      return false;
    }

    function setGate({ signedIn, authorized }){
      const accessCard = document.getElementById('accessCard');
      const adminContent = document.getElementById('adminContent');
      const gateMsg = document.getElementById('gateMsg');
      if(!signedIn){
        gateMsg.textContent = 'Please sign in to see the admin tools.';
        accessCard.style.display = 'block';
        adminContent.style.display = 'none';
      } else if(!authorized){
        gateMsg.textContent = 'You are signed in, but not authorized for Admin. Please contact an admin.';
        accessCard.style.display = 'block';
        adminContent.style.display = 'none';
      } else {
        accessCard.style.display = 'none';
        adminContent.style.display = 'block';
      }
    }

    onAuthStateChanged(auth, async (user)=>{
      if(user){
        avatar.style.display='flex';
        avatar.textContent = (user.displayName||user.email||'?').slice(0,1).toUpperCase();
        info.textContent = `Signed in as ${user.email||user.displayName}`;
        document.body.dataset.authed = '1';
        isAuthorized = await checkAccess(user);
        setGate({ signedIn:true, authorized:isAuthorized });
        if(isAuthorized){ fillContentTable(); }
      } else {
        avatar.style.display='none'; avatar.textContent='';
        info.textContent = 'Not signed in.';
        document.body.dataset.authed = '';
        isAuthorized = false;
        setGate({ signedIn:false, authorized:false });
      }
    });

    // ---------- Data model fields ----------
    const MOVIE_FIELDS = ["id","type","slug","title_en","title_original","year","poster","backdrop","short_description","genres","age_rating","runtime_min","release_date","franchise","status","rating","favorite","on_watchlist","tags","rewatch_count","rewatch_dates","last_position_seconds","created_at","updated_at"];
    const SERIES_FIELDS = ["id","type","slug","title_en","title_original","year","poster","backdrop","short_description","genres","age_rating","series_status","platform","episode_length_min","status","rating","favorite","on_watchlist","tags","rewatch_count","rewatch_dates","created_at","updated_at"];
    const EPISODE_FIELDS = ["series_slug","season_number","episode_number","code","title","air_date","watched","rating","notes","runtime_min"];

    function slugify(title, year){ return (title+"-"+year).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/-+/g,'-').replace(/^-|-$/g,''); }

    // ---------- Quick Add ----------
    document.getElementById('btnQuickAdd').addEventListener('click', async()=>{
      if(!(auth.currentUser)){ showToast('Please sign in first'); return; }
      if(!isAuthorized){ showToast('Not authorized'); return; }
      const type = (document.getElementById('qaType').value);
      const title_en = document.getElementById('qaTitle').value.trim();
      const title_original = document.getElementById('qaOriginal').value.trim();
      const year = Number(document.getElementById('qaYear').value);
      const poster = document.getElementById('qaPoster').value.trim();
      const backdrop = document.getElementById('qaBackdrop').value.trim();
      const genres = document.getElementById('qaGenres').value.trim();
      const age = document.getElementById('qaAge').value.trim();
      const runtime = Number(document.getElementById('qaRuntime').value);
      const platform = document.getElementById('qaPlatform').value.trim();
      if(!title_en || !year || !poster){ showToast('Need Title, Year, Poster'); return; }
      if(type==='movie' && !genres && !runtime){ showToast('Movie: need Genres or Runtime'); return; }
      if(type==='series' && !genres && !platform){ showToast('Series: need Genres or Platform'); return; }

      const slug = slugify(title_en, year);
      const base = { slug, title_en, title_original, year, poster, backdrop, short_description:'', genres: genres? genres.split('|') : [], age_rating: age, status:'Plan to Watch', rating:0, favorite:false, on_watchlist:false, tags:[], rewatch:{count:0,dates:[]}, created_at:new Date().toISOString(), updated_at:new Date().toISOString() };
      if(type==='movie'){
        await setDoc(doc(db,'movies', slug), { id: slug, type:'movie', ...base, runtime_min: runtime||0, release_date:'', franchise:null, last_position_seconds:0 }, { merge:true });
      } else {
        await setDoc(doc(db,'series', slug), { id: slug, type:'series', ...base, series_status:'running', platform, episode_length_min:0, seasons:[] }, { merge:true });
      }
      showToast('Saved'); fillContentTable();
    });

    // ---------- Import context ----------
    const importCtx = { headers:[], rows:[], mapping:{}, dataset:'movies', workbook:null };

    // ---------- Mapping UI ----------
    function buildMapUI(){
      const dataset = importCtx.dataset;
      if (dataset === 'workbook'){
        // Kein Mapping n√∂tig ‚Äì nur Info anzeigen
        const s = importCtx.workbook?.series?.length || 0;
        const se = importCtx.workbook?.seasons?.length || 0;
        const ep = importCtx.workbook?.episodes?.length || 0;
        document.getElementById('mapTable').innerHTML =
          `<div class="pill">Workbook detected: <strong>series ${s}</strong> ‚Ä¢ <strong>seasons ${se}</strong> ‚Ä¢ <strong>episodes ${ep}</strong></div>`;
        document.getElementById('mapPreview').innerHTML = '';
        return;
      }

      const fields =
        dataset==='movies'  ? MOVIE_FIELDS  :
        dataset==='series'  ? SERIES_FIELDS :
        /* episodes */        EPISODE_FIELDS;

      importCtx.mapping = Object.fromEntries(fields.map(f=> [f, importCtx.headers.includes(f)? f : ""]));
      const sel = (name,val)=> `<select data-map="${name}"><option value="">(none)</option>${importCtx.headers.map(h=>`<option ${h===val?'selected':''}>${h}</option>`).join('')}</select>`;
      const rows = fields.map(f=> `<tr><td>${f}</td><td>${sel(f, importCtx.mapping[f])}</td></tr>`).join('');
      document.getElementById('mapTable').innerHTML = `<table class='table'><thead><tr><th>Field</th><th>File column</th></tr></thead><tbody>${rows}</tbody></table>`;
      document.querySelectorAll('#mapTable select').forEach(s=> s.addEventListener('change', e=>{ importCtx.mapping[e.target.dataset.map]=e.target.value; buildPreview(); }));
      buildPreview();
    }

    function buildPreview(){
      if (importCtx.dataset === 'workbook'){ return; }
      const fields =
        importCtx.dataset==='movies'  ? MOVIE_FIELDS  :
        importCtx.dataset==='series'  ? SERIES_FIELDS :
        EPISODE_FIELDS;

      const preview = importCtx.rows.slice(0,3).map((r,i)=>{
        const mapped = Object.fromEntries(fields.map(f=> [f, importCtx.mapping[f]? r[importCtx.mapping[f]] : '' ]));
        return `<pre>#${i+1} ${JSON.stringify(mapped, null, 2)}</pre>`;
      }).join('');
      document.getElementById('mapPreview').innerHTML = `<div>Preview (first 3 rows):</div>${preview}`;
    }

    // ---------- File reading ----------
    function readWorkbookAllSheets(file){
      return new Promise((resolve,reject)=>{
        const reader = new FileReader();
        reader.onload = (ev)=>{
          try{
            const data = new Uint8Array(ev.target.result);
            const wb = XLSX.read(data, { type:'array' });
            const get = (name)=> XLSX.utils.sheet_to_json(wb.Sheets[name] || {}, { defval:'' });
            resolve({ series:get('series'), seasons:get('seasons'), episodes:get('episodes') });
          }catch(err){ reject(err); }
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }

    function readSingleSheet(file){
      return new Promise((resolve,reject)=>{
        const reader = new FileReader();
        reader.onload = (ev)=>{
          try{
            const data = new Uint8Array(ev.target.result);
            const wb = XLSX.read(data, { type:'array' });
            const ws = wb.Sheets[wb.SheetNames[0]];
            const rows = XLSX.utils.sheet_to_json(ws, { defval:'' });
            resolve(rows);
          }catch(err){ reject(err); }
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }

    document.getElementById('csvFile').addEventListener('change', async (e)=>{
      const f = e.target.files[0]; if(!f) return;
      try{
        const name = (f.name||'').toLowerCase();
        if (name.endsWith('.xlsx') || name.endsWith('.xls')){
          // Pr√ºfe, ob es ein Workbook mit den drei erwarteten Sheets ist
          const wb = await readWorkbookAllSheets(f);
          const hasAny = (wb.series?.length||0) + (wb.seasons?.length||0) + (wb.episodes?.length||0) > 0;
          if (hasAny){
            importCtx.dataset = 'workbook';
            importCtx.workbook = wb;
            importCtx.headers = []; importCtx.rows = [];
            buildMapUI();
          } else {
            // Fallback: Erste Tabelle als Mapping-Import
            const rows = await readSingleSheet(f);
            importCtx.headers = rows.length? Object.keys(rows[0]) : [];
            importCtx.rows = rows;
            importCtx.dataset = document.getElementById('mapDataset').value;
            buildMapUI();
          }
        } else {
          // CSV
          await new Promise((resolve)=>{
            Papa.parse(f, { header:true, skipEmptyLines:true, complete: (res)=>{
              importCtx.headers = res.meta.fields||[];
              importCtx.rows = res.data||[];
              resolve();
            }});
          });
          importCtx.dataset = document.getElementById('mapDataset').value;
          buildMapUI();
        }
      }catch(err){
        console.error(err);
        showToast('Failed to read file');
      }finally{
        e.target.value='';
      }
    });

    document.getElementById('mapDataset').addEventListener('change', ()=>{
      if(importCtx.dataset !== 'workbook'){ importCtx.dataset = document.getElementById('mapDataset').value; buildMapUI(); }
    });

    // ---------- Import logic ----------
    async function runImport(){
      if(!(auth.currentUser)){ showToast('Please sign in first'); return; }
      if(!isAuthorized){ showToast('Not authorized'); return; }

      // A) Workbook-Flow: series + seasons + episodes in einem XLSX
      if (importCtx.dataset === 'workbook'){
        let sAdded=0,sUpdated=0,seaAdded=0,epAdded=0,epUpdated=0,missing=0;

        // 1) SERIES upsert
        for (const obj of (importCtx.workbook.series||[])){
          if(!obj.slug || !obj.title_en) continue;
          obj.type = 'series';
          obj.genres = String(obj.genres||'').split('|').filter(Boolean);
          obj.tags   = String(obj.tags||'').split('|').filter(Boolean);
          obj.favorite = String(obj.favorite).toLowerCase()==='true';
          obj.on_watchlist = String(obj.on_watchlist).toLowerCase()==='true';
          obj.rating = Number(obj.rating||0)||0;
          obj.year = Number(obj.year||0)||0;
          const ref = doc(db,'series', obj.slug);
          const ex  = await getDoc(ref);
          await setDoc(ref, { ...obj, updated_at:new Date().toISOString() }, { merge:true });
          ex.exists() ? sUpdated++ : sAdded++;
        }

        // 2) SEASONS optional (legt Stubs an / aktualisiert Titel/Note)
        for (const r of (importCtx.workbook.seasons||[])){
          const slug = String(r.series_slug||'').trim(); if(!slug) continue;
          const sNum = Number(r.season_number||0); if(!sNum) continue;
          const sRef = doc(db,'series', slug); const sSnap = await getDoc(sRef);
          if(!sSnap.exists()){ missing++; continue; }
          const serie   = sSnap.data()||{};
          const seasons = Array.isArray(serie.seasons)? [...serie.seasons] : [];
          let idx = seasons.findIndex(s=> Number(s.season_number)===sNum);
          if(idx === -1){ seasons.push({ season_number:sNum, episodes:[], title:r.season_title||'', note:r.note||'' }); seaAdded++; }
          else { seasons[idx] = { ...seasons[idx], title:r.season_title||seasons[idx].title, note:r.note||seasons[idx].note }; }
          await setDoc(sRef, { seasons, updated_at:new Date().toISOString() }, { merge:true });
        }

        // 3) EPISODES upsert (legt fehlende Staffeln automatisch an)
        const pad2 = n => String(Math.max(0, Number(n)||0)).padStart(2,'0');
        const bySeries = {};
        for (const r of (importCtx.workbook.episodes||[])){
          const slug = String(r.series_slug||'').trim(); if(!slug) continue;
          (bySeries[slug] ||= []).push(r);
        }
        for (const slug of Object.keys(bySeries)){
          const sRef = doc(db,'series', slug); const snap = await getDoc(sRef);
          if(!snap.exists()){ missing++; continue; }
          const serie = snap.data()||{};
          const seasons = Array.isArray(serie.seasons)? [...serie.seasons] : [];

          const ensureSeason = (num)=>{
            let i = seasons.findIndex(s=> Number(s.season_number)===Number(num));
            if(i===-1){ seasons.push({ season_number:Number(num), episodes:[] }); i=seasons.length-1; }
            if(!Array.isArray(seasons[i].episodes)) seasons[i].episodes=[];
            return i;
          };

          for (const r of bySeries[slug]){
            const sNum = Number(r.season_number||1);
            const eNum = Number(r.episode_number||0);
            const idx  = ensureSeason(sNum);
            const code = String(r.code||`S${pad2(sNum)}E${pad2(eNum)}`);
            const ep = {
              code,
              episode_number: eNum || undefined,
              title: r.title || '',
              air_date: r.air_date || '',
              watched: String(r.watched).toLowerCase()==='true',
              rating: Number(r.rating||0)||0,
              notes: r.notes || '',
              runtime_min: Number(r.runtime_min||0) || undefined
            };
            const list = seasons[idx].episodes;
            const byCode = list.findIndex(x => (x.code||'') === code);
            const byNum  = list.findIndex(x => Number(x.episode_number||0) === eNum && eNum>0);
            if (byCode>=0 || byNum>=0){ list[byCode>=0?byCode:byNum] = { ...list[byCode>=0?byCode:byNum], ...ep }; epUpdated++; }
            else { list.push(ep); epAdded++; }
            list.sort((a,b)=>{
              const an=Number(a.episode_number||0), bn=Number(b.episode_number||0);
              return an && bn ? an-bn : String(a.code||'').localeCompare(String(b.code||''));
            });
          }
          await setDoc(sRef, { seasons, updated_at:new Date().toISOString() }, { merge:true });
        }

        showToast(`Workbook: series +${sAdded}/${sUpdated} ‚Ä¢ seasons +${seaAdded} ‚Ä¢ episodes +${epAdded}/${epUpdated}${missing?` ‚Ä¢ missing series ${missing}`:''}`);
        fillContentTable?.();
        return;
      }

      // B) CSV/XLSX Einzelsheet ‚Äì Mapping f√ºr movies / series / episodes
      const fields = (importCtx.dataset==='movies'? MOVIE_FIELDS : importCtx.dataset==='series' ? SERIES_FIELDS : EPISODE_FIELDS);
      const dupSlug = document.getElementById('chkDupSlug').checked;
      const dupTY = document.getElementById('chkDupTitleYear').checked;
      let added=0, skipped=0, duplicates=0, updated=0;

      if (importCtx.dataset === 'episodes'){
        // Episodes upsert gegen bestehende series.<slug>.seasons[].episodes
        const bySeries = {};
        for (const r of importCtx.rows){
          const row = Object.fromEntries(fields.map(f=> [f, importCtx.mapping[f] ? r[importCtx.mapping[f]] : '' ]));
          const slug = String(row.series_slug||'').trim(); if(!slug) { skipped++; continue; }
          (bySeries[slug] ||= []).push(row);
        }
        const pad2 = n => String(Math.max(0, Number(n)||0)).padStart(2,'0');

        for (const slug of Object.keys(bySeries)){
          const sRef = doc(db, 'series', slug);
          const sSnap = await getDoc(sRef);
          if(!sSnap.exists()){ skipped++; continue; }
          const serie = sSnap.data() || {};
          const seasons = Array.isArray(serie.seasons) ? [...serie.seasons] : [];

          const ensureSeason = (num)=>{
            let i = seasons.findIndex(s=> Number(s.season_number)===Number(num));
            if (i === -1){ seasons.push({ season_number:Number(num), episodes:[] }); i = seasons.length - 1; }
            if(!Array.isArray(seasons[i].episodes)) seasons[i].episodes = [];
            return i;
          };

          for (const r of bySeries[slug]){
            const sNum = Number(r.season_number||1);
            const eNum = Number(r.episode_number||0);
            const idx  = ensureSeason(sNum);
            const code = String(r.code||`S${pad2(sNum)}E${pad2(eNum)}`);
            const ep = {
              code,
              episode_number: eNum || undefined,
              title: r.title || '',
              air_date: r.air_date || '',
              watched: String(r.watched).toLowerCase()==='true',
              rating: Number(r.rating||0)||0,
              notes: r.notes || '',
              runtime_min: Number(r.runtime_min||0) || undefined
            };
            const list = seasons[idx].episodes;
            const byCode = list.findIndex(x => (x.code||'') === code);
            const byNum  = list.findIndex(x => Number(x.episode_number||0) === eNum && eNum>0);
            if (byCode>=0 || byNum>=0){ list[byCode>=0?byCode:byNum] = { ...list[byCode>=0?byCode:byNum], ...ep }; updated++; }
            else { list.push(ep); added++; }
            list.sort((a,b)=>{
              const an=Number(a.episode_number||0), bn=Number(b.episode_number||0);
              return an && bn ? an-bn : String(a.code||'').localeCompare(String(b.code||''));
            });
          }

          await setDoc(sRef, { seasons, updated_at:new Date().toISOString() }, { merge:true });
        }
        showToast(`Episodes: +${added} updated ${updated}${skipped?` ‚Ä¢ skipped ${skipped}`:''}`);
        fillContentTable?.();
        return;
      }

      // movies / series
      for (const r of importCtx.rows){
        const obj = Object.fromEntries(fields.map(f=> [f, importCtx.mapping[f]? r[importCtx.mapping[f]] : '' ]));
        const type = importCtx.dataset.slice(0,-1); // movie / series
        obj.type = type;
        obj.year = Number(String(obj.year).replace(',','.'))||0;
        obj.genres = (obj.genres||'').split('|').filter(Boolean);
        obj.tags = (obj.tags||'').split('|').filter(Boolean);
        obj.rating = Number(String(obj.rating).replace(',','.'))||0;
        obj.favorite = String(obj.favorite).toLowerCase()==='true';
        obj.on_watchlist = String(obj.on_watchlist).toLowerCase()==='true';
        obj.rewatch = { count: Number(obj.rewatch_count||0)||0, dates: (obj.rewatch_dates||'').split('|').filter(Boolean) };
        obj.created_at = obj.created_at || new Date().toISOString();
        obj.updated_at = obj.updated_at || new Date().toISOString();
        if(!obj.slug && obj.title_en && obj.year){ obj.slug = slugify(obj.title_en, obj.year); }

        // Requireds
        if(!(obj.title_en && obj.year && obj.poster)){ skipped++; continue; }
        if(type==='movie' && !(obj.genres.length>0 || Number(obj.runtime_min||0)>0)){ skipped++; continue; }
        if(type==='series' && !(obj.genres.length>0 || (obj.platform||''))){ skipped++; continue; }

        const ref = doc(db, importCtx.dataset, obj.slug);
        if(dupSlug){ const ex = await getDoc(ref); if(ex.exists()){ duplicates++; skipped++; continue; } }
        if(dupTY){
          const all = await getDocs(collection(db, importCtx.dataset));
          const collision = all.docs.some(d=> (d.data().title_en||'')===obj.title_en && String(d.data().year||'')===String(obj.year||''));
          if(collision){ duplicates++; skipped++; continue; }
        }
        await setDoc(ref, obj, { merge:true });
        added++;
      }
      showToast(`Imported ${added}, skipped ${skipped}${duplicates? ' (duplicates '+duplicates+')':''}`);
      fillContentTable();
    }

    document.getElementById('mapImport').addEventListener('click', runImport);

    // ---------- Content list ----------
    async function fillContentTable(){
      const tbody = document.querySelector('#contentTable tbody');
      tbody.innerHTML='';
      for (const name of ['movies','series']){
        try{
          const snap = await getDocs(query(collection(db, name), orderBy('updated_at','desc')));
          snap.forEach(docSnap=>{
            const x = { type: name.slice(0,-1), id: docSnap.id, ...docSnap.data() };
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${x.type}</td><td>${x.title_en||''}</td><td>${x.year||''}</td><td>${x.status||''}</td><td>${x.platform||''}</td><td>${x.rating||0}</td><td>${(x.updated_at||'').slice(0,10)}</td><td><button class='icon-btn' data-del='${name}|${x.id}'>Delete</button></td>`;
            tbody.appendChild(tr);
          });
        }catch(err){
          const snap = await getDocs(collection(db, name)); // Fallback ohne orderBy
          snap.forEach(docSnap=>{
            const x = { type: name.slice(0,-1), id: docSnap.id, ...docSnap.data() };
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${x.type}</td><td>${x.title_en||''}</td><td>${x.year||''}</td><td>${x.status||''}</td><td>${x.platform||''}</td><td>${x.rating||0}</td><td>${(x.updated_at||'').slice(0,10)}</td><td><button class='icon-btn' data-del='${name}|${x.id}'>Delete</button></td>`;
            tbody.appendChild(tr);
          });
        }
      }
      tbody.querySelectorAll('[data-del]').forEach(btn=> btn.addEventListener('click', async()=>{
        if(!(auth.currentUser) || !isAuthorized){ showToast('Not authorized'); return; }
        const [coll, id] = btn.dataset.del.split('|');
        const ref = doc(db, coll, id);
        await setDoc(ref, { __deleted:true }, { merge:true }); // soft delete
        showToast('Marked as deleted (soft delete)');
        fillContentTable();
      }));
    }

    // No eager calls; admin content activates after authorization.
  </script>
</body>
</html>
